import{AttributePart,directive,PropertyPart}from"../lit-html.js";class ClassList{constructor(element){this.classes=new Set;this.changed=false;this.element=element;const classList=(element.getAttribute("class")||"").split(/\s+/);for(const cls of classList){this.classes.add(cls)}}add(cls){this.classes.add(cls);this.changed=true}remove(cls){this.classes.delete(cls);this.changed=true}commit(){if(this.changed){let classString="";this.classes.forEach(cls=>classString+=cls+" ");this.element.setAttribute("class",classString)}}}const previousClassesCache=new WeakMap;export const classMap=directive(classInfo=>part=>{if(!(part instanceof AttributePart)||part instanceof PropertyPart||part.committer.name!=="class"||part.committer.parts.length>1){throw new Error("The `classMap` directive must be used in the `class` attribute "+"and must be the only part in the attribute.")}const{committer:committer}=part;const{element:element}=committer;let previousClasses=previousClassesCache.get(part);if(previousClasses===undefined){element.setAttribute("class",committer.strings.join(" "));previousClassesCache.set(part,previousClasses=new Set)}const classList=element.classList||new ClassList(element);previousClasses.forEach(name=>{if(!(name in classInfo)){classList.remove(name);previousClasses.delete(name)}});for(const name in classInfo){const value=classInfo[name];if(value!=previousClasses.has(name)){if(value){classList.add(name);previousClasses.add(name)}else{classList.remove(name);previousClasses.delete(name)}}}if(typeof classList.commit==="function"){classList.commit()}});